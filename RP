#!/usr/bin/env python
# coding: utf-8
# RP, a micro Radio Paradise Player
# Relies on mplayer + libnotify for OSD
#
# You can use mplayer bindings to control play. By default:
# - q to exit
# - / and * for vol- and vol +
# - see mplayer man pages for others
#
# Author: Anisse Astier <anisse@astier.eu>


# Python 3 compatibility
from __future__ import print_function
import sys
PYTHON3 = sys.version_info >= (3, 0)
if PYTHON3:
    b = lambda s : str(s, encoding='utf8') # buffer(urlopen, file reading) conversion to strings for parsing
    from urllib.request import urlopen
    # pynotify is for now only compatible with python 2 :-(
    # Implement a stub for python 3
    class pynotify:
        init = lambda s : None
        uninit = lambda : None
        class Notification:
            __init__ = lambda s, s1, s2 : None
            set_timeout = lambda s, i : None
            update = lambda s, s1, s2, s3 : None
            show = close = lambda s : None
else:
    b = lambda s : s
    from urllib2 import urlopen
    import pynotify

import tempfile
import subprocess
import os
import cgi
import posixpath # for URL manipulation
import time

class CachedCoverFetcher:
    def __init__(self, cachedir):
        self.coverdir = cachedir + '/covers'
        if not os.path.isdir(self.coverdir):
            os.makedirs(self.coverdir) # we expect OSError to be thrown to caller in case of failure

    def get_image(self, imgurl):
        # get basename
        imgpath = self.coverdir + '/' + posixpath.basename(imgurl)
        # check if it's in the cache
        if os.path.exists(imgpath):
            return imgpath
        # Specially for Radio Paradise:
        # small image is enough for our cache and display purpose.
        if imgurl.find('graphics/covers/m') != -1:
            # we try the small image first, then the provided URL
            urlist = [imgurl.replace('graphics/covers/m', 'graphics/covers/s'), imgurl]
        else:
            urlist = [imgurl]
        # download image in cache
        page = None
        content = None
        for url in urlist:
            try:
                page = urlopen(url)
                content = page.read()
                if len(content) <= 807: #this is hack to skip empty 1x1 GIF files
                    page = content = None
                    continue
            except: # we *really* want to ignore any error here.
                pass
            else: # stop at the first working url
                break
        if page == None or content == None: # no working url :-(
            return None

        try:
            f = open(imgpath, 'wb')
            f.write(content)
            f.close()
        except: #whatever happened in file creation/writing, we just don't have any image to show
            return None
        return imgpath

# TODO: in case cache cannot be initialized, we should use the temporary file code below
class TmpCoverFetcher:
    def get_imagetmp(self, imgurl):
        try:
            img = urlopen(imgurl).read()
            tmpfile = tempfile.NamedTemporaryFile(suffix='.jpg', delete=False)
            tmpfile.write(img)
            tmpfile.close()
            imgfilepath = tmpfile.name
        except: #whatever happened(URL, fetching, tempfile creationâ€¦), we just don't have any image to show
            imgfilepath = None
        return imgfilepath

    def cleanup_imagetmp(self, imgfilepath):
        if imgfilepath != None and os.path.exists(imgfilepath):
            os.unlink(imgfilepath)


class Player:
    def __init__(self, playlisturl):
        pynotify.init("RP")
        self.notif = pynotify.Notification("RP", "A micro Radio Paradise player")
        self.notif.set_timeout(3500)

        playlist = urlopen(playlisturl).read() #TODO: check for errors
        self.cmd = ['mplayer', '-vo', 'null', '-quiet'] + b(playlist).split('\n')

        self.cache_dir = os.getcwd() +  '/cache'
        self.fetcher = CachedCoverFetcher(self.cache_dir)

    def __del__(self):
        self.notif.close()
        self.notif = None # loose object reference to allow uninit
        pynotify.uninit()

    def _parse_icyinfo(self, icystring):
        #parsing sample:
        # ICY Info: StreamTitle='Jimi Hendrix - The Wind Cries Mary';StreamUrl='http://www.radioparadise.com/graphics/covers/m/B000002OOG.jpg';
        if icystring.find("ICY Info: StreamTitle=") == -1:
            return None,None,None

        streamurl = artist = songname = ""
        l = icystring[len('ICY Info: '):] #remove prefix
        for tok in l.split(';'):
            if len(tok) < 2: # remove strings that are empty or non-matching
                continue
            tokname,tokvalue = tok.split('=', 1)
            if tokname == "StreamTitle":
                song = tokvalue.strip("'")
                artist,songname = song.split(" - ", 1)
            elif tokname == "StreamUrl":
                    streamurl = tokvalue.strip("'")
        return artist,songname,streamurl

    def _now_playing(self, artist, song, imgurl):
        # Log everything that is played
        log = open(self.cache_dir + '/log', 'a')
        log.write('"%s","%s","%s","%s"\n' %
                (time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime()),
                    imgurl,artist,song))
        log.close()

        imgpath = self.fetcher.get_image(imgurl)
        self._show_current(artist, song, imgpath)
    #    self.fetcher.cleanup_img(imgpath)

    def _show_current(self, text, subtext, imgfilepath):
        # libnotify "Summary" is allowed to contain HTML markup. Escape HTML chars.
        subtext = cgi.escape(subtext)
        self.notif.update(text, subtext, imgfilepath)
        self.notif.show()

    def play(self):
        try:
            p = subprocess.Popen(self.cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        except:
            print("Unable to run mplayer. Do you have it installed on your system ?")
            sys.exit(1)
        while p.poll() == None:
            try:
                l = p.stdout.readline()
                artist,song,coverurl = self._parse_icyinfo(b(l))
                if artist == song == coverurl == None:
                    continue
                print("%s - %s"%(artist,song))
                self._now_playing(artist, song, coverurl)
            except KeyboardInterrupt:
                p.terminate()
                #time.sleep(1)
                #p.kill()


#TODO:
# - keep playlist in a cache (then randomize order for load-balancing)
# - Add a setup.py to allow installation and python packaging
# - Put cache in a "real" cache directory (e.g /var/cache/)
# - use gstreamer instead of mplayer


def main():
    player = Player("http://www.radioparadise.com/musiclinks/rp_128aac.m3u")
    player.play()

if __name__ == '__main__':
    main()
